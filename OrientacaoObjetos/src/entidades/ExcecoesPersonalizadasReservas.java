package entidades;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

import entidades.excecoes.ExcecoesPersonalizadasExcecao;

public class ExcecoesPersonalizadasReservas {
	
	private Integer numeroQuarto;
	private Date checkIn;
	private Date checkOut;
	
	// Estando declarado como estatico não é instanciado a cada novo objeto e sim apenas
	// uma vez, pois pertence a classe e não ao objeto
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	
	
	public ExcecoesPersonalizadasReservas(Integer numeroQuarto, Date checkIn, Date checkOut) throws ExcecoesPersonalizadasExcecao {
		Date agora = new Date();
		if ( checkIn.before(agora) || checkOut.before(agora) ) {
			// Lançando essa exceção no construtor tb vamos nos beneficiar do try/catch utilizado
			// na função que utiliza este objeto, sem que precisemos mudar nada na função
			// que cria este objeto se a instanciação estiver ja entre Try/catch
			throw new ExcecoesPersonalizadasExcecao("Data de checkIn ou checkOut não pode ser anterior a data atual");
		} else if(checkIn.after(checkOut)){
			throw new ExcecoesPersonalizadasExcecao("Data de checkIn não pode ser posterior a data de checkOut");
		}
		this.numeroQuarto = numeroQuarto;
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}
	
	
	
	public Integer getNumeroQuarto() {
		return numeroQuarto;
	}



	public void setNumeroQuarto(Integer numeroQuarto) {
		this.numeroQuarto = numeroQuarto;
	}



	public Date getCheckIn() {
		return checkIn;
	}



	public Date getCheckOut() {
		return checkOut;
	}


	public void atualizaDatas(Date checkIN, Date checkOUT) throws ExcecoesPersonalizadasExcecao {
		
		Date agora = new Date();
		if ( checkIN.before(agora) || checkOUT.before(agora) ) {
			// Lançando uma exceção que ja existe no java sem ter que criar uma classe de exceção
			// particular, no caso como é um argumento invalido ou checkIn ou checkOut
			// então podemos lançar a IllegalArgumentException
			// Ao lançar uma exceção devemos trata-la, deveriamos colocar essa linha do throw
			// entre um try/catch, porém como queremos que a função que chama esta classe
			// trate o erro então propagamos a exceção na assinatura do metodo através
			// do comando throws, no caso da IllegalArgumentException o compilador não
			// exigiu a propagação porque ela herda a classe RuntimeException que não exige
			// tratamento try/catch
			// throw new IllegalArgumentException("Data de checkIn ou checkOut não pode ser anterior a data atual");
			
			
				// Agora vamos lançar uma exceção personalizada
			    // Ao lançar uma exceção devemos trata-la, deveriamos colocar essa linha do throw
			    // entre um try/catch, porém como queremos que a função que chama esta classe
			    // trate o erro então propagamos a exceção na assinatura do metodo através
			    // do comando throws
				throw new ExcecoesPersonalizadasExcecao("Data de checkIn ou checkOut não pode ser anterior a data atual");

		} else if(checkIN.after(checkOUT)){
			throw new ExcecoesPersonalizadasExcecao("Data de checkIn não pode ser posterior a data de checkOut");
		} else {	
		
			this.checkIn = checkIN;
			this.checkOut = checkOUT;
		}
	}
	
	//Calculo para diferença entre duas datas
	public Long duracao() {
		// pega o valor da data em milissegundos e faz a diferença
		long diferenca = checkOut.getTime() - checkIn.getTime();
		//Esta classe do java TimeUnit é um tipo enumerado complexo com algumas operações
		// neste caso vamos converter o valor em milissegundos da diferença em 
		// dias, é possivel converter em horas, minutos...
		return TimeUnit.DAYS.convert(diferenca, TimeUnit.MILLISECONDS );
	}



	@Override
	public String toString() {
		// TODO Auto-generated method stub
		return "Quarto: " + numeroQuarto + ", CheckIn: " + sdf.format(checkIn) +
				", CheckOut: " + sdf.format(checkOut) + ", Dias: " +
				this.duracao();
	}
	
	
	
	
}
